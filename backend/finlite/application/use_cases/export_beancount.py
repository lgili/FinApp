"""
Export Beancount Use Case - Exporta ledger para formato Beancount.

Responsabilidade: Converter contas e transações para formato plain-text Beancount.
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Optional

from finlite.domain.repositories.account_repository import IAccountRepository
from finlite.domain.repositories.transaction_repository import ITransactionRepository
from finlite.infrastructure.persistence.unit_of_work import UnitOfWork


@dataclass
class ExportBeancountCommand:
    """Command para exportar Beancount."""

    output_path: Path
    from_date: Optional[datetime] = None  # Se None, exporta tudo
    to_date: Optional[datetime] = None
    include_metadata: bool = True  # Include tags and metadata
    operating_currency: str = "USD"


@dataclass
class ExportBeancountResult:
    """Resultado do export."""

    output_path: Path
    accounts_count: int
    transactions_count: int
    file_size_bytes: int


class ExportBeancountUseCase:
    """
    Use case para exportar ledger em formato Beancount.

    Beancount format: https://beancount.github.io/docs/beancount_language_syntax.html

    Estrutura do arquivo:
    1. Header com options
    2. Account declarations
    3. Transactions em ordem cronológica

    Examples:
        >>> result = use_case.execute(
        ...     ExportBeancountCommand(
        ...         output_path=Path("~/ledger.beancount"),
        ...         operating_currency="USD"
        ...     )
        ... )
        >>> print(f"Exported {result.transactions_count} transactions")
    """

    def __init__(
        self,
        uow: UnitOfWork,
        account_repository: IAccountRepository,
        transaction_repository: ITransactionRepository,
    ):
        """
        Initialize use case.

        Args:
            uow: Unit of Work
            account_repository: Repository de contas
            transaction_repository: Repository de transactions
        """
        self.uow = uow
        self.account_repository = account_repository
        self.transaction_repository = transaction_repository

    def execute(self, command: ExportBeancountCommand) -> ExportBeancountResult:
        """
        Executa export para Beancount.

        Args:
            command: Comando com parâmetros

        Returns:
            Resultado do export
        """
        with self.uow:
            # 1. Buscar contas
            accounts = self.account_repository.list_all()

            # 2. Buscar transactions
            if command.from_date or command.to_date:
                from_date = command.from_date or datetime(1970, 1, 1)
                to_date = command.to_date or datetime(2100, 12, 31)
                transactions = self.transaction_repository.find_by_date_range(
                    from_date=from_date,
                    to_date=to_date,
                )
            else:
                # Buscar todas (limit alto)
                transactions = self.transaction_repository.list_all(limit=100000)

            # Ordenar por data
            transactions.sort(key=lambda t: t.date)

            # 3. Buscar contas por ID para lookup
            accounts_by_id = {acc.id: acc for acc in accounts}

            # 4. Gerar conteúdo Beancount
            lines: list[str] = []

            # Header
            lines.append("; Beancount Ledger")
            lines.append(f"; Exported: {datetime.now().isoformat()}")
            lines.append(f"; Generated by Finlite")
            lines.append("")
            lines.append(f'option "operating_currency" "{command.operating_currency}"')
            lines.append("")

            # Account declarations
            lines.append("; === Account Declarations ===")
            lines.append("")
            for account in sorted(accounts, key=lambda a: a.code):
                # Format: 2025-01-01 open Assets:Bank:Checking USD
                open_date = account.created_at.date().isoformat()
                currency = account.currency or command.operating_currency
                lines.append(f"{open_date} open {account.code} {currency}")
            lines.append("")

            # Transactions
            lines.append("; === Transactions ===")
            lines.append("")
            for txn in transactions:
                # Transaction header
                # Format: 2025-10-12 * "Description"
                txn_date = txn.date.isoformat()
                description = txn.description.replace('"', '\\"')  # Escape quotes
                lines.append(f'{txn_date} * "{description}"')

                # Tags (se incluir metadata)
                if command.include_metadata and txn.tags:
                    tags_str = " ".join(f"#{tag}" for tag in txn.tags)
                    lines.append(f"  {tags_str}")

                # Postings
                for posting in txn.postings:
                    account = accounts_by_id.get(posting.account_id)
                    if not account:
                        continue

                    amount = posting.amount.amount
                    currency = posting.amount.currency

                    # Format:   Assets:Bank:Checking  -100.00 USD
                    # Beancount usa espaços para alinhar
                    account_part = f"  {account.code}".ljust(50)
                    amount_str = f"{amount:>12.2f} {currency}"
                    lines.append(f"{account_part} {amount_str}")

                lines.append("")  # Linha em branco entre transactions

            # 5. Escrever arquivo
            output_path = command.output_path.expanduser()
            output_path.parent.mkdir(parents=True, exist_ok=True)

            content = "\n".join(lines)
            output_path.write_text(content, encoding="utf-8")

            file_size = output_path.stat().st_size

            return ExportBeancountResult(
                output_path=output_path,
                accounts_count=len(accounts),
                transactions_count=len(transactions),
                file_size_bytes=file_size,
            )
