# ADR-0001: Foundational architecture for Finlite

## Status

Accepted â€” 2025-09-27

## Context

Finlite aims to be a local-first, double-entry accounting system with a CLI-first experience. The foundational phase must establish durable infrastructure: SQLite storage with migrations, a composable domain core, and tooling for quality (lint, types, tests). Future phases (rules, ML, web UI) will layer on top of this base without rewriting the core.

Key constraints:

- Single-user, local-first deployment
- Deterministic, auditable operations (double-entry)
- Room to evolve towards API/UI without breaking data model

## Decision

We split the repository into a `backend` Python package (core + CLI), `docs` for design records, and `examples` for sample datasets. The backend uses:

- **Typer** for the CLI entry point (`fin`), leveraging Rich for ergonomic output
- **SQLAlchemy 2.0** with **Alembic** migrations over SQLite (WAL mode, foreign key enforcement)
- **Pydantic Settings** for `.env`-driven configuration (data directory, locale, currency)
- **pytest**, **mypy**, **ruff**, and **pre-commit** for quality gates

The domain schema starts with accounts, transactions, postings, import batches, statement entries, and rules. Repositories/services encapsulate validations (e.g., balanced postings) and will be extended in later phases.

## Consequences

- Database migrations exist from day one; switching to Postgres later only requires adapting SQLAlchemy connection strings and migrations.
- Structured CLI commands make it easy to script operations and later share logic with a web API.
- Quality tooling and tests guard against regressions and enforce the double-entry invariant.
- Future phases (rules engine, ML, reports) can build on the established package layout.
